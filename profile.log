FUNCTION  ale_linters#javascript#standard#GetCommand()
Called 1 time
Total time:   0.000551
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000549   0.000018     return ale_linters#javascript#standard#GetExecutable(a:buffer)   . ' ' . ale#Var(a:buffer, 'javascript_standard_options')   . ' --stdin %s'

FUNCTION  1()
Called 4 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
    4              0.000137         return self.title . ": " . a:leader.a:msg

FUNCTION  <SNR>19_OpenDirHere()
Called 26 times
Total time:   0.075853
 Self time:   0.000879

count  total (s)   self (s)
   26              0.000231     if isdirectory(a:dir)
    4              0.000012         let l:focal_dir = a:dir
    4              0.000019         let l:focal_file = bufnr("%")
    4              0.000046         if (has("win16") || has("win32") || has("win64")) && !&shellslash
                                        let l:focal_dir = substitute(l:focal_dir, '/', '\\', 'g')
                                        let l:focal_file = substitute(l:focal_file, '/', '\\', 'g')
                                    endif
    4   0.075016   0.000042         call filebeagle#FileBeagleOpen(l:focal_dir, l:focal_file)
    4              0.000007     endif

FUNCTION  ale#linter#Get()
Called 29 times
Total time:   0.008127
 Self time:   0.004994

count  total (s)   self (s)
   29              0.000076     let l:combined_linters = []
                            
                                " Handle dot-seperated filetypes.
   70              0.000340     for l:original_filetype in split(a:original_filetypes, '\.')
   41   0.001192   0.000320         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
                            
                                    " Try and get a list of linters to run, using the original file type,
                                    " not the aliased filetype. We have some linters to limit by default,
                                    " and users may define their own list of linters to run.
   41              0.000313         let l:linter_names = get(   g:ale_linters,   l:original_filetype,   get(       s:default_ale_linters,       l:original_filetype,       'all'   ))
                            
   41   0.002557   0.000296         let l:all_linters = ale#linter#GetAll(l:filetype)
   41              0.000094         let l:filetype_linters = []
                            
   41              0.000234         if type(l:linter_names) == type('') && l:linter_names ==# 'all'
   27              0.000061             let l:filetype_linters = l:all_linters
   27              0.000076         elseif type(l:linter_names) == type([])
                                        " Select only the linters we or the user has specified.
   98              0.000201             for l:linter in l:all_linters
   84              0.000358                 if index(l:linter_names, l:linter.name) >= 0
   14              0.000083                     call add(l:filetype_linters, l:linter)
   14              0.000014                 endif
   84              0.000095             endfor
   14              0.000025         endif
                            
   41              0.000151         call extend(l:combined_linters, l:filetype_linters)
   41              0.000039     endfor
                            
   29              0.000045     return l:combined_linters

FUNCTION  FileBeagleStatusLineHiddenInfo()
Called 13 times
Total time:   0.000578
 Self time:   0.000578

count  total (s)   self (s)
   13              0.000050     if !exists('b:filebeagle_directory_viewer')
                                    return ''
                                endif
   13              0.000064     let l:label_hidden_dotfiles = get(a:000, 0, 'dotfiles')
   13              0.000044     let l:label_hidden_wildignore = get(a:000, 1, 'wildignore')
   13              0.000039     let l:label_separator = get(a:000, 2, ', ')
   13              0.000024     let l:status_line = []
   13              0.000044     if empty(b:filebeagle_directory_viewer.is_include_hidden)
   13              0.000057         call add(l:status_line, l:label_hidden_dotfiles)
   13              0.000012     endif
   13              0.000073     if empty(b:filebeagle_directory_viewer.is_include_ignored) && !empty(&wildignore)
   13              0.000042         call add(l:status_line, l:label_hidden_wildignore)
   13              0.000010     endif
   13              0.000069     return join(l:status_line, l:label_separator)

FUNCTION  <SNR>80_VisitedBufferRequiresReparse()
Called 26 times
Total time:   0.001715
 Self time:   0.000425

count  total (s)   self (s)
   26   0.001471   0.000181   if !s:AllowedToCompleteInCurrentBuffer()
    9              0.000011     return 0
                              endif
                            
   17              0.000060   if bufnr( '' ) ==# s:previous_allowed_buffer_number
    1              0.000002     return 0
                              endif
   16              0.000051   let s:previous_allowed_buffer_number = bufnr( '' )
   16              0.000015   return 1

FUNCTION  6()
Called 4 times
Total time:   0.074895
 Self time:   0.074751

count  total (s)   self (s)
    4              0.074285         redraw
    4              0.000099         echohl None
    4   0.000501   0.000357         echo self.format_message("", a:msg)

FUNCTION  <SNR>205_InvokeChain()
Called 1 time
Total time:   0.003378
 Self time:   0.000118

count  total (s)   self (s)
    1   0.000768   0.000028     let l:options = ale#engine#ProcessChain(a:buffer, a:linter, a:chain_index, a:input)
                            
    1              0.000003     if !empty(l:options)
    1   0.002586   0.000066         call s:RunJob(l:options)
    1              0.000003     elseif empty(g:ale_buffer_info[a:buffer].job_list)
                                    " If we cancelled running a command, and we have no jobs in progress,
                                    " then delete the managed temporary files now.
                                    call ale#engine#RemoveManagedFiles(a:buffer)
                                endif

FUNCTION  FileBeagleStatusLineCurrentDirInfo()
Called 13 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
   13              0.000173     return exists("b:filebeagle_directory_viewer") ? b:filebeagle_directory_viewer.focus_dir : ''

FUNCTION  ale#util#GetFunction()
Called 3 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    3              0.000017     if type(a:string_or_ref) == type('')
    3              0.000014         return function(a:string_or_ref)
                                endif
                            
                                return a:string_or_ref

FUNCTION  ale#sign#FindCurrentSigns()
Called 1 time
Total time:   0.000195
 Self time:   0.000026

count  total (s)   self (s)
    1   0.000037   0.000012     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
    1   0.000158   0.000014     return ale#sign#ParseSigns(l:line_list)

FUNCTION  ale#highlight#UpdateHighlights()
Called 27 times
Total time:   0.002914
 Self time:   0.001645

count  total (s)   self (s)
   27              0.000227     let l:buffer = bufnr('%')
   27              0.000188     let l:has_new_items = has_key(s:buffer_highlights, l:buffer)
   27              0.000142     let l:loclist = l:has_new_items ? remove(s:buffer_highlights, l:buffer) : []
                            
   27              0.000073     if l:has_new_items || !g:ale_enabled
    1   0.001282   0.000013         call ale#highlight#RemoveHighlights(l:loclist)
    1              0.000000     endif
                            
                                " Remove anything with a current match_id
   27              0.000145     call filter(l:loclist, '!has_key(v:val, ''match_id'')')
                            
   27              0.000040     if l:has_new_items
    4              0.000005         for l:item in l:loclist
    3              0.000004             let l:col = l:item.col
    3              0.000007             let l:group = l:item.type ==# 'E' ? 'ALEError' : 'ALEWarning'
    3              0.000005             let l:line = l:item.lnum
    3              0.000002             let l:size = 1
                            
                                        " Rememeber the match ID for the item.
                                        " This ID will be used to preserve loclist items which are set
                                        " many times.
    3              0.000027             let l:item.match_id = matchaddpos(l:group, [[l:line, l:col, l:size]])
    3              0.000004         endfor
    1              0.000000     endif

FUNCTION  <SNR>205_HandleExitVim()
Called 1 time
Total time:   0.008986
 Self time:   0.000220

count  total (s)   self (s)
    1   0.008984   0.000218     call s:HandleExit(ch_getjob(a:channel))

FUNCTION  ale#engine#ParseVim8ProcessID()
Called 8 times
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
    8              0.000139     return matchstr(a:job_string, '\d\+') + 0

FUNCTION  <SNR>80_AllowedToCompleteInCurrentBuffer()
Called 50 times
Total time:   0.002506
 Self time:   0.000378

count  total (s)   self (s)
   50   0.002481   0.000353   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  <SNR>205_RunJob()
Called 1 time
Total time:   0.002520
 Self time:   0.001775

count  total (s)   self (s)
    1              0.000004     let l:command = a:options.command
    1              0.000003     let l:buffer = a:options.buffer
    1              0.000003     let l:linter = a:options.linter
    1              0.000003     let l:output_stream = a:options.output_stream
    1              0.000004     let l:next_chain_index = a:options.next_chain_index
    1              0.000003     let l:read_buffer = a:options.read_buffer
                            
    1   0.000157   0.000029     let [l:temporary_file, l:command] = ale#engine#FormatCommand(l:buffer, l:command)
                            
    1              0.000005     if l:read_buffer && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
    1   0.000066   0.000026         let l:temporary_file = s:TemporaryFilename(l:buffer)
    1              0.000022         let l:command = l:command . ' < ' . fnameescape(l:temporary_file)
    1              0.000001     endif
                            
    1   0.000475   0.000026     if s:CreateTemporaryFileForJob(l:buffer, l:temporary_file)
                                    " If a temporary filename has been formatted in to the command, then
                                    " we do not need to send the Vim buffer to the command.
    1              0.000004         let l:read_buffer = 0
    1              0.000001     endif
                            
    1              0.000007     if !has('nvim')
                                    " The command will be executed in a subshell. This fixes a number of
                                    " issues, including reading the PATH variables correctly, %PATHEXT%
                                    " expansion on Windows, etc.
                                    "
                                    " NeoVim handles this issue automatically if the command is a String.
    1              0.000038         let l:command = has('win32')   ?  'cmd /c ' . l:command   : split(&shell) + split(&shellcmdflag) + [l:command]
    1              0.000002     endif
                            
    1              0.000006     if get(g:, 'ale_run_synchronously') == 1
                                    " Find a unique Job value to use, which will be the same as the ID for
                                    " running commands synchronously. This is only for test code.
                                    let l:job = len(s:job_info_map) + 1
                            
                                    while has_key(s:job_info_map, l:job)
                                        let l:job += 1
                                    endwhile
                                elseif has('nvim')
                                    if l:output_stream ==# 'stderr'
                                        " Read from stderr instead of stdout.
                                        let l:job = jobstart(l:command, {   'on_stderr': function('s:GatherOutputNeoVim'),   'on_exit': function('s:HandleExitNeoVim'),})
                                    elseif l:output_stream ==# 'both'
                                        let l:job = jobstart(l:command, {   'on_stdout': function('s:GatherOutputNeoVim'),   'on_stderr': function('s:GatherOutputNeoVim'),   'on_exit': function('s:HandleExitNeoVim'),})
                                    else
                                        let l:job = jobstart(l:command, {   'on_stdout': function('s:GatherOutputNeoVim'),   'on_exit': function('s:HandleExitNeoVim'),})
                                    endif
                                else
    1              0.000016         let l:job_options = {   'in_mode': 'nl',   'out_mode': 'nl',   'err_mode': 'nl',   'close_cb': function('s:HandleExitVim'),}
                            
    1              0.000003         if g:ale_history_enabled
                                        " We only need to capture the exit status if we are going to
                                        " save it in the history. Otherwise, we don't care.
    1              0.000009             let l:job_options.exit_cb = function('s:HandleExitStatusVim')
    1              0.000001         endif
                            
    1              0.000003         if l:output_stream ==# 'stderr'
                                        " Read from stderr instead of stdout.
                                        let l:job_options.err_cb = function('s:GatherOutputVim')
                                    elseif l:output_stream ==# 'both'
                                        " Read from both streams.
                                        let l:job_options.out_cb = function('s:GatherOutputVim')
                                        let l:job_options.err_cb = function('s:GatherOutputVim')
                                    else
    1              0.000007             let l:job_options.out_cb = function('s:GatherOutputVim')
    1              0.000001         endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
    1              0.001203         let l:job = job_start(l:command, l:job_options)
    1              0.000002     endif
                            
    1              0.000003     let l:status = 'failed'
    1              0.000002     let l:job_id = 0
                            
                                " Only proceed if the job is being run.
    1              0.000028     if has('nvim') || get(g:, 'ale_run_synchronously') == 1 || (l:job !=# 'no process' && job_status(l:job) ==# 'run')
                                    " Add the job to the list of jobs, so we can track them.
    1              0.000021         call add(g:ale_buffer_info[l:buffer].job_list, l:job)
                            
    1              0.000002         let l:status = 'started'
    1   0.000188   0.000094         let l:job_id = s:GetJobID(l:job)
                                    " Store the ID for the job in the map to read back again.
    1              0.000024         let s:job_info_map[l:job_id] = {   'linter': l:linter,   'buffer': l:buffer,   'output': [],   'next_chain_index': l:next_chain_index,}
    1              0.000002     endif
                            
    1              0.000002     if g:ale_history_enabled
    1   0.000068   0.000034         call ale#history#Add(l:buffer, l:status, l:job_id, l:command)
    1              0.000001     else
                                    let g:ale_buffer_info[l:buffer].history = []
                                endif
                            
    1              0.000003     if get(g:, 'ale_run_synchronously') == 1
                                    " Run a command synchronously if this test option is set.
                                    let s:job_info_map[l:job_id].output = systemlist(   type(l:command) == type([])   ?  join(l:command[0:1]) . ' ' . shellescape(l:command[2])   : l:command)
                                    call s:HandleExit(l:job)
                                endif

FUNCTION  <SNR>74_IndentLinesEnable()
Called 53 times
Total time:   0.000366
 Self time:   0.000366

count  total (s)   self (s)
   53              0.000247     if exists("b:indentLine_enabled") && b:indentLine_enabled
   53              0.000057         return
                                else
                                    let b:indentLine_enabled = 1
                                endif
                                call s:SetConcealOption()
                            
                                let g:mysyntaxfile = g:indentLine_mysyntaxfile
                            
                                let space = &l:shiftwidth is 0 ? &l:tabstop : &l:shiftwidth
                            
                                if g:indentLine_showFirstIndentLevel
                                    execute 'syntax match IndentLine /^ / containedin=ALL conceal cchar=' . g:indentLine_first_char
                                endif
                            
                                if g:indentLine_faster
                                    execute 'syntax match IndentLineSpace /^\s\+/ containedin=ALL contains=IndentLine'
                                    execute 'syntax match IndentLine / \{'.(space-1).'}\zs / contained conceal cchar=' . g:indentLine_char
                                    execute 'syntax match IndentLine /\t\zs / contained conceal cchar=' . g:indentLine_char
                                else
                                    let pattern = line('$') < g:indentLine_maxLines ? 'v' : 'c'
                                    for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
                                        execute 'syntax match IndentLine /\%(^\s\+\)\@<=\%'.i.pattern.' / containedin=ALL conceal cchar=' . g:indentLine_char
                                    endfor
                                endif

FUNCTION  ale#Var()
Called 5 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    5              0.000024     let l:full_name = 'ale_' . a:variable_name
                            
    5              0.000040     return getbufvar(a:buffer, l:full_name, g:[l:full_name])

FUNCTION  <SNR>205_GetJobID()
Called 8 times
Total time:   0.000326
 Self time:   0.000181

count  total (s)   self (s)
    8              0.000045     if has('nvim')
                                    "In NeoVim, job values are just IDs.
                                    return a:job
                                endif
                            
                                " For Vim 8, the job is a different variable type, and we can parse the
                                " process ID from the string.
    8   0.000242   0.000097     return ale#engine#ParseVim8ProcessID(string(a:job))

FUNCTION  ale#ShouldDoNothing()
Called 53 times
Total time:   0.004536
 Self time:   0.001211

count  total (s)   self (s)
                                " Do nothing for blacklisted files
                                " OR if ALE is running in the sandbox
   53   0.004413   0.001088     return index(g:ale_filetype_blacklist, &filetype) >= 0   || (exists('*getcmdwintype') && !empty(getcmdwintype()))   || ale#util#InSandbox()

FUNCTION  ale_linters#javascript#standard#Handle()
Called 1 time
Total time:   0.000278
 Self time:   0.000073

count  total (s)   self (s)
                                " Matches patterns line the following:
                                "
                                " /path/to/some-filename.js:47:14: Strings must use singlequote.
                                " /path/to/some-filename.js:56:41: Expected indentation of 2 spaces but found 4.
                                " /path/to/some-filename.js:13:3: Parsing error: Unexpected token
    1              0.000002     let l:pattern = '^.*:\(\d\+\):\(\d\+\): \(.\+\)$'
    1              0.000001     let l:output = []
                            
    4   0.000226   0.000021     for l:match in ale#util#GetMatches(a:lines, l:pattern)
    3              0.000003         let l:type = 'Error'
    3              0.000005         let l:text = l:match[3]
                            
    3              0.000024         call add(l:output, {   'bufnr': a:buffer,   'lnum': l:match[1] + 0,   'col': l:match[2] + 0,   'text': l:text,   'type': 'E',})
    3              0.000002     endfor
                            
    1              0.000001     return l:output

FUNCTION  ale#path#FindNearestFile()
Called 2 times
Total time:   0.001005
 Self time:   0.001005

count  total (s)   self (s)
    2              0.000109     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
                            
    2              0.000863     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
    2              0.000010     if !empty(l:relative_path)
                                    return fnamemodify(l:relative_path, ':p')
                                endif
                            
    2              0.000003     return ''

FUNCTION  <SNR>80_DisableOnLargeFile()
Called 39 times
Total time:   0.000294
 Self time:   0.000294

count  total (s)   self (s)
   39              0.000179   if exists( 'b:ycm_largefile' )
   39              0.000066     return b:ycm_largefile
                              endif
                            
                              let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
                              let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
                              if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
                              endif
                              return b:ycm_largefile

FUNCTION  ale#history#SetExitCode()
Called 1 time
Total time:   0.000029
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000021   0.000009     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
    1              0.000002     if !empty(l:obj)
                                    " If we find a match, then set the code and status.
    1              0.000002         let l:obj.exit_code = a:exit_code
    1              0.000001         let l:obj.status = 'finished'
    1              0.000001     endif

FUNCTION  <SNR>207_FindHistoryItem()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
    1              0.000006     for l:obj in reverse(g:ale_buffer_info[a:buffer].history[:])
    1              0.000002         if l:obj.job_id == a:job_id
    1              0.000001             return l:obj
                                    endif
                                endfor
                            
                                return {}

FUNCTION  <SNR>208_PlaceNewSigns()
Called 1 time
Total time:   0.001753
 Self time:   0.001753

count  total (s)   self (s)
                                " Add the new signs,
    3              0.000009     for l:index in range(0, len(a:grouped_items) - 1)
    2              0.000007         let l:sign_id = l:index + g:ale_sign_offset + 1
    2              0.000005         let l:sublist = a:grouped_items[l:index]
    2              0.000023         let l:type = !empty(filter(copy(l:sublist), 'v:val.type ==# ''E'''))   ? 'ALEErrorSign'   : 'ALEWarningSign'
                            
                                    " Save the sign IDs we are setting back on our loclist objects.
                                    " These IDs will be used to preserve items which are set many times.
    5              0.000006         for l:obj in l:sublist
    3              0.000007             let l:obj.sign_id = l:sign_id
    3              0.000001         endfor
                            
    2              0.001667         execute 'sign place ' . l:sign_id   . ' line=' . l:sublist[0].lnum   . ' name=' . l:type   . ' buffer=' . a:buffer
    2              0.000003     endfor

FUNCTION  ale#cursor#EchoCursorWarning()
Called 25 times
Total time:   0.005801
 Self time:   0.001606

count  total (s)   self (s)
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   25              0.000346     if mode() !=# 'n'
    1              0.000001         return
                                endif
                            
   24   0.002900   0.000316     let [l:info, l:loc] = s:FindItemAtCursor()
                            
   24              0.000066     if !empty(l:loc)
    6   0.000560   0.000102         let l:msg = s:GetMessage(l:loc.linter_name, l:loc.type, l:loc.text)
    6   0.001200   0.000047         call ale#cursor#TruncatedEcho(l:msg)
    6              0.000025         let l:info.echoed = 1
    6              0.000016     elseif get(l:info, 'echoed')
                                    " We'll only clear the echoed message when moving off errors once,
                                    " so we don't continually clear the echo line.
                                    echo
                                    let l:info.echoed = 0
                                endif

FUNCTION  <SNR>74_Setup()
Called 53 times
Total time:   0.003374
 Self time:   0.002698

count  total (s)   self (s)
   53              0.000275     if index(g:indentLine_fileTypeExclude, &filetype) isnot -1
                                    let &l:concealcursor = ""
                                    let &l:conceallevel = "0"
                                    return
                                endif
                            
   53              0.000232     if len(g:indentLine_fileType) isnot 0 && index(g:indentLine_fileType, &filetype) is -1
                                    return
                                endif
                            
   53              0.000139     for name in g:indentLine_bufNameExclude
                                    if matchstr(bufname(''), name) is bufname('')
                                        return
                                    endif
                                endfor
                            
   53              0.000097     if &filetype ==# ""
    4   0.000334   0.000024         call s:InitColor()
    4              0.000004     endif
                            
   53              0.000080     if g:indentLine_enabled
   53   0.000678   0.000312         call s:IndentLinesEnable()
   53              0.000037     endif
                            
   53              0.000153     if g:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceEnable()
                                endif

FUNCTION  <SNR>205_HandleExit()
Called 1 time
Total time:   0.008766
 Self time:   0.000302

count  total (s)   self (s)
    1              0.000008     if a:job ==# 'no process'
                                    " Stop right away when the job is not valid in Vim 8.
                                    return
                                endif
                            
    1   0.000052   0.000009     let l:job_id = s:GetJobID(a:job)
                            
    1              0.000004     if !has_key(s:job_info_map, l:job_id)
                                    return
                                endif
                            
    1              0.000003     let l:job_info = s:job_info_map[l:job_id]
    1              0.000003     let l:linter = l:job_info.linter
    1              0.000001     let l:output = l:job_info.output
    1              0.000002     let l:buffer = l:job_info.buffer
    1              0.000002     let l:next_chain_index = l:job_info.next_chain_index
                            
                                " Call the same function for stopping jobs again to clean up the job
                                " which just closed.
    1   0.000328   0.000007     call s:StopPreviousJobs(l:buffer, l:linter)
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
    1   0.000101   0.000051     if ale#util#InSandbox()
                                    return
                                endif
                            
    1              0.000006     if l:next_chain_index < len(get(l:linter, 'command_chain', []))
                                    call s:InvokeChain(l:buffer, l:linter, l:next_chain_index, l:output)
                                    return
                                endif
                            
                                " Log the output of the command for ALEInfo if we should.
    1              0.000002     if g:ale_history_enabled && g:ale_history_log_output
                                    call ale#history#RememberOutput(l:buffer, l:job_id, l:output[:])
                                endif
                            
    1   0.000308   0.000022     let l:linter_loclist = ale#util#GetFunction(l:linter.callback)(l:buffer, l:output)
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
    1   0.000180   0.000015     let l:linter_loclist = ale#engine#FixLocList(l:buffer, l:linter, l:linter_loclist)
                            
                                " Add the loclist items from the linter.
                                " loclist items for files which are checked go into a different list,
                                " and are kept between runs.
    1              0.000002     if l:linter.lint_file
                                    call extend(g:ale_buffer_info[l:buffer].lint_file_loclist, l:linter_loclist)
                                else
    1              0.000005         call extend(g:ale_buffer_info[l:buffer].new_loclist, l:linter_loclist)
    1              0.000001     endif
                            
    1              0.000003     if !empty(g:ale_buffer_info[l:buffer].job_list)
                                    " Wait for all jobs to complete before doing anything else.
                                    return
                                endif
                            
                                " Automatically remove all managed temporary files and directories
                                " now that all jobs have completed.
    1   0.000323   0.000014     call ale#engine#RemoveManagedFiles(l:buffer)
                            
                                " Combine the lint_file List and the List for everything else.
    1              0.000005     let l:combined_list = g:ale_buffer_info[l:buffer].lint_file_loclist   + g:ale_buffer_info[l:buffer].new_loclist
                            
                                " Sort the loclist again.
                                " We need a sorted list so we can run a binary search against it
                                " for efficient lookup of the messages in the cursor handler.
    1   0.000036   0.000019     call sort(l:combined_list, 'ale#util#LocItemCompare')
                            
                                " Now swap the old and new loclists, after we have collected everything
                                " and sorted the list again.
    1              0.000022     let g:ale_buffer_info[l:buffer].loclist = l:combined_list
    1              0.000003     let g:ale_buffer_info[l:buffer].new_loclist = []
                            
    1   0.007091   0.000013     call ale#engine#SetResults(l:buffer, g:ale_buffer_info[l:buffer].loclist)
                            
                                " Call user autocommands. This allows users to hook into ALE's lint cycle.
    1   0.000236   0.000041     silent doautocmd User ALELint

FUNCTION  ale#sign#SetSigns()
Called 1 time
Total time:   0.005565
 Self time:   0.002513

count  total (s)   self (s)
                                " Find the current markers
    1   0.000209   0.000014     let l:current_sign_list = ale#sign#FindCurrentSigns(a:buffer)
                            
    1   0.000074   0.000013     call s:UpdateLineNumbers(l:current_sign_list, a:loclist)
                            
    1   0.000059   0.000013     let l:grouped_items = s:GroupLoclistItems(a:loclist)
                            
                                " Set the dummy sign if we need to.
                                " This keeps the sign gutter open while we remove things, etc.
    1   0.001012   0.000015     let l:is_dummy_sign_set = s:SetDummySignIfNeeded(   a:buffer,   l:current_sign_list,   !empty(l:grouped_items),)
                            
                                " Now remove the previous signs. The dummy will hold the column open
                                " while we add the new signs, if we had signs before.
    3              0.000007     for [l:line, l:sign_id, l:name] in l:current_sign_list
    2              0.000004         if l:sign_id != g:ale_sign_offset
    2              0.001765             exec 'sign unplace ' . l:sign_id . ' buffer=' . a:buffer
    2              0.000002         endif
    2              0.000002     endfor
                            
    1   0.001768   0.000015     call s:PlaceNewSigns(a:buffer, l:grouped_items)
                            
                                " Remove the dummy sign now we've updated the signs, unless we want
                                " to keep it, which will keep the sign column open even when there are
                                " no warnings or errors.
    1              0.000003     if l:is_dummy_sign_set && !g:ale_sign_column_always
    1              0.000648         execute 'sign unplace ' . g:ale_sign_offset . ' buffer=' . a:buffer
    1              0.000001     endif

FUNCTION  ale#engine#InitBufferInfo()
Called 3 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    3              0.000014     if !has_key(g:ale_buffer_info, a:buffer)
                                    " job_list will hold the list of jobs
                                    " loclist holds the loclist items after all jobs have completed.
                                    " lint_file_loclist holds items from the last run including linters
                                    "   which use the lint_file option.
                                    " new_loclist holds loclist items while jobs are being run.
                                    " temporary_file_list holds temporary files to be cleaned up
                                    " temporary_directory_list holds temporary directories to be cleaned up
                                    " history holds a list of previously run commands for this buffer
    1              0.000009         let g:ale_buffer_info[a:buffer] = {   'job_list': [],   'loclist': [],   'lint_file_loclist': [],   'new_loclist': [],   'temporary_file_list': [],   'temporary_directory_list': [],   'history': [],}
    1              0.000001     endif

FUNCTION  <SNR>210_GetALEMatches()
Called 1 time
Total time:   0.001208
 Self time:   0.001208

count  total (s)   self (s)
    1              0.000002     let l:list = []
                            
  147              0.000421     for l:match in getmatches()
  146              0.000379         if l:match['group'] ==# 'ALEError' || l:match['group'] ==# 'ALEWarning'
                                        call add(l:list, l:match)
                                    endif
  146              0.000099     endfor
                            
    1              0.000002     return l:list

FUNCTION  ale#engine#ManageDirectory()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000010     call add(g:ale_buffer_info[a:buffer].temporary_directory_list, a:directory)

FUNCTION  <SNR>74_InitColor()
Called 4 times
Total time:   0.000310
 Self time:   0.000310

count  total (s)   self (s)
    4              0.000005     if ! g:indentLine_setColors
                                    return
                                endif
                            
    4              0.000010     if ! exists("g:indentLine_color_term")
                                    if &background ==# "light"
                                        let term_color = 249
                                    else
                                        let term_color = 239
                                    endif
                                else
    4              0.000007         let term_color = g:indentLine_color_term
    4              0.000003     endif
                            
    4              0.000011     if ! exists("g:indentLine_color_gui")
                                    if &background ==# "light"
                                        let gui_color = "Grey70"
                                    else
                                        let gui_color = "Grey30"
                                    endif
                                else
    4              0.000005         let gui_color = g:indentLine_color_gui
    4              0.000002     endif
                            
    4              0.000106     execute "highlight Conceal ctermfg=" . term_color . " ctermbg=NONE"
    4              0.000056     execute "highlight Conceal guifg=" . gui_color .  " guibg=NONE"
                            
    4              0.000006     if &term ==# "linux"
                                    if &background ==# "light"
                                        let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
                                    else
                                        let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
                                    endif
                                    execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
                                endif

FUNCTION  FileBeagleStatusLineFilterAndHiddenInfo()
Called 13 times
Total time:   0.001162
 Self time:   0.000475

count  total (s)   self (s)
   13              0.000060     if !exists("b:filebeagle_directory_viewer")
                                    return ""
                                endif
   13              0.000034     let l:status_line = ""
   13   0.000688   0.000110     if !empty(FileBeagleStatusLineHiddenInfo())
   13              0.000061         let l:status_line .= "[+HIDE]"
   13              0.000012     endif
   13   0.000183   0.000074     if !empty(FileBeagleStatusLineFilterInfo())
                                    let l:status_line .= "[+FILTER:" . FileBeagleStatusLineFilterInfo() . "]"
                                endif
   13              0.000020     return l:status_line

FUNCTION  <SNR>80_SetOmnicompleteFunc()
Called 16 times
Total time:   0.005009
 Self time:   0.000401

count  total (s)   self (s)
   16   0.004719   0.000111   if s:Pyeval( 'ycm_state.NativeFiletypeCompletionUsable()' )
   12              0.000113     let &omnifunc = 'youcompleteme#OmniComplete'
   12              0.000035     let &l:omnifunc = 'youcompleteme#OmniComplete'
                            
                              " If we don't have native filetype support but the omnifunc is set to YCM's
                              " omnifunc because the previous file the user was editing DID have native
                              " support, we remove our omnifunc.
   12              0.000018   elseif &omnifunc == 'youcompleteme#OmniComplete'
                                let &omnifunc = ''
                                let &l:omnifunc = ''
                              endif

FUNCTION  ale#engine#ProcessChain()
Called 1 time
Total time:   0.000740
 Self time:   0.000176

count  total (s)   self (s)
    1              0.000007     let l:output_stream = get(a:linter, 'output_stream', 'stdout')
    1              0.000004     let l:read_buffer = a:linter.read_buffer
    1              0.000003     let l:chain_index = a:chain_index
    1              0.000003     let l:input = a:input
                            
    1              0.000004     if has_key(a:linter, 'command_chain')
                                    while l:chain_index < len(a:linter.command_chain)
                                        " Run a chain of commands, one asychronous command after the other,
                                        " so that many programs can be run in a sequence.
                                        let l:chain_item = a:linter.command_chain[l:chain_index]
                            
                                        if l:chain_index == 0
                                            " The first callback in the chain takes only a buffer number.
                                            let l:command = ale#util#GetFunction(l:chain_item.callback)(   a:buffer)
                                        else
                                            " The second callback in the chain takes some input too.
                                            let l:command = ale#util#GetFunction(l:chain_item.callback)(   a:buffer,   l:input)
                                        endif
                            
                                        if !empty(l:command)
                                            " We hit a command to run, so we'll execute that
                            
                                            " The chain item can override the output_stream option.
                                            if has_key(l:chain_item, 'output_stream')
                                                let l:output_stream = l:chain_item.output_stream
                                            endif
                            
                                            " The chain item can override the read_buffer option.
                                            if has_key(l:chain_item, 'read_buffer')
                                                let l:read_buffer = l:chain_item.read_buffer
                                            elseif l:chain_index != len(a:linter.command_chain) - 1
                                                " Don't read the buffer for commands besides the last one
                                                " in the chain by default.
                                                let l:read_buffer = 0
                                            endif
                            
                                            break
                                        endif
                            
                                        " Command chain items can return an empty string to indicate that
                                        " a command should be skipped, so we should try the next item
                                        " with no input.
                                        let l:input = []
                                        let l:chain_index += 1
                                    endwhile
                                elseif has_key(a:linter, 'command_callback')
                                    " If there is a callback for generating a command, call that instead.
    1   0.000601   0.000037         let l:command = ale#util#GetFunction(a:linter.command_callback)(a:buffer)
    1              0.000001     else
                                    let l:command = a:linter.command
                                endif
                            
    1              0.000004     if empty(l:command)
                                    " Don't run any jobs if the command is an empty string.
                                    return {}
                                endif
                            
    1              0.000015     return {   'command': l:command,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': l:output_stream,   'next_chain_index': l:chain_index + 1,   'read_buffer': l:read_buffer,}

FUNCTION  <SNR>23_can_diffoff()
Called 49 times
Total time:   0.000789
 Self time:   0.000789

count  total (s)   self (s)
   49              0.000718   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  ale_linters#javascript#standard#GetExecutable()
Called 2 times
Total time:   0.001200
 Self time:   0.000075

count  total (s)   self (s)
    2   0.000052   0.000019     if ale#Var(a:buffer, 'javascript_standard_use_global')
                                    return ale#Var(a:buffer, 'javascript_standard_executable')
                                endif
                            
    2   0.001135   0.000043     return ale#path#ResolveLocalPath(   a:buffer,   'node_modules/.bin/standard',   ale#Var(a:buffer, 'javascript_standard_executable'))

FUNCTION  <SNR>82_EchoWithShortMess()
Called 6 times
Total time:   0.001006
 Self time:   0.001006

count  total (s)   self (s)
                                " We need to remember the setting for shormess and reset it again.
    6              0.000040     let l:shortmess_options = getbufvar('%', '&shortmess')
                            
    6              0.000006     try
                                    " Turn shortmess on or off.
    6              0.000010         if a:setting ==# 'on'
    6              0.000055             setlocal shortmess+=T
                                        " echomsg is neede for the message to get truncated and appear in
                                        " the message history.
    6              0.000621             exec "norm! :echomsg a:message\n"
    6              0.000018         elseif a:setting ==# 'off'
                                        setlocal shortmess-=T
                                        " Regular echo is needed for printing newline characters.
                                        echo a:message
                                    else
                                        throw 'Invalid setting: ' . string(a:setting)
                                    endif
    6              0.000011     finally
    6              0.000100         call setbufvar('%', '&shortmess', l:shortmess_options)
    6              0.000011     endtry

FUNCTION  <SNR>208_IsDummySignSet()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000004     for [l:line, l:id, l:name] in a:current_id_list
    1              0.000002         if l:id == g:ale_sign_offset
                                        return 1
                                    endif
                            
    1              0.000001         if l:line > 1
    1              0.000001             return 0
                                    endif
                                endfor
                            
                                return 0

FUNCTION  <SNR>179_MatchColorValue()
Called 2646 times
Total time:   0.092734
 Self time:   0.092734

count  total (s)   self (s)
 2646              0.007944   if ! len(a:color) | return | endif
                            
 2646              0.007550     let group = 'cssColor' . tolower(a:color)
                            
 2646              0.008139   if !exists('b:color_pattern[a:part]')
                                exe s:fg_color_calc
                                exe 'syn cluster cssColors add='.group
                                exe 'hi' group s:color_prefix.'bg='.color s:color_prefix.'fg='.s:FGForBG(a:color)
                                let b:color_pattern[a:part] = a:color
                              endif
                            
 2646              0.005351   if !exists('b:matchescache')
   18              0.000034     let b:matchescache = {}
   18              0.000031   elseif !exists('b:matchescache[a:part]')
 2628              0.024467     let b:matchescache[a:part] = matchadd(group, a:part, -1)
 2628              0.001989   endif
                            
                              "call add(w:matchescache, matchadd(group, a:part, -1))
                            
 2646              0.002274   return ''

FUNCTION  <SNR>80_Pyeval()
Called 50 times
Total time:   0.016324
 Self time:   0.016324

count  total (s)   self (s)
   50              0.000089   if s:using_python3
                                return py3eval( a:eval_string )
                              endif
   50              0.015960   return pyeval( a:eval_string )

FUNCTION  filebeagle#FileBeagleOpen()
Called 4 times
Total time:   0.074974
 Self time:   0.000079

count  total (s)   self (s)
    4              0.000020     if exists("b:filebeagle_directory_viewer")
    4   0.074938   0.000043         call s:_filebeagle_messenger.send_info("Use 'CTRL-W CTRL-V' or 'CTRL-W CTRL-S' to spawn a new FileBeagle viewer on the current directory")
    4              0.000009         return
                                endif
                                let directory_viewer = s:NewDirectoryViewer()
                                if empty(a:focus_dir)
                                    let focus_dir = getcwd()
                                else
                                    let focus_dir = fnamemodify(a:focus_dir, ":p")
                                endif
                                if !isdirectory(focus_dir)
                                    call s:_filebeagle_messenger.send_error("Not a valid directory: '" . focus_dir . "'")
                                else
                                    call directory_viewer.open_dir( a:filebeagle_buf_num, focus_dir, bufname("%"), bufnr("%"), [], {}, 0, "", g:filebeagle_show_hidden, g:filebeagle_show_hidden)
                                endif

FUNCTION  ale#Queue()
Called 26 times
Total time:   0.011021
 Self time:   0.002000

count  total (s)   self (s)
   26              0.000144     if len(a:0) > 1
                                    throw 'too many arguments!'
                                endif
                            
                                " Default linting_flag to ''
   26              0.000122     let l:linting_flag = get(a:000, 0, '')
                            
   26              0.000086     if l:linting_flag !=# '' && l:linting_flag !=# 'lint_file'
                                    throw "linting_flag must be either '' or 'lint_file'"
                                endif
                            
   26   0.002004   0.000130     if ale#ShouldDoNothing()
                                    return
                                endif
                            
                                " Remember that we want to check files for this buffer.
                                " We will remember this until we finally run the linters, via any event.
   26              0.000069     if l:linting_flag ==# 'lint_file'
   26              0.000207         let s:should_lint_file_for_buffer[bufnr('%')] = 1
   26              0.000022     endif
                            
   26              0.000043     if s:lint_timer != -1
   20              0.000079         call timer_stop(s:lint_timer)
   20              0.000034         let s:lint_timer = -1
   20              0.000013     endif
                            
   26   0.007385   0.000238     let l:linters = ale#linter#Get(&filetype)
   26              0.000071     if len(l:linters) == 0
                                    " There are no linters to lint with, so stop here.
    6              0.000005         return
                                endif
                            
   20              0.000031     if a:delay > 0
   20              0.000138         let s:lint_timer = timer_start(a:delay, function('ale#Lint'))
   20              0.000016     else
                                    call ale#Lint()
                                endif

FUNCTION  <SNR>210_GetCurrentMatchIDs()
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000002     let l:current_id_map = {}
                            
    4              0.000005     for l:item in a:loclist
    3              0.000005         if has_key(l:item, 'match_id')
                                        let l:current_id_map[l:item.match_id] = 1
                                    endif
    3              0.000001     endfor
                            
    1              0.000002     return l:current_id_map

FUNCTION  <SNR>205_GatherOutputVim()
Called 3 times
Total time:   0.000175
 Self time:   0.000076

count  total (s)   self (s)
    3   0.000138   0.000039     let l:job_id = s:GetJobID(ch_getjob(a:channel))
                            
    3              0.000010     if !has_key(s:job_info_map, l:job_id)
                                    return
                                endif
                            
    3              0.000013     call add(s:job_info_map[l:job_id].output, a:data)

FUNCTION  <SNR>179_RestoreColors()
Called 18 times
Total time:   0.130324
 Self time:   0.037590

count  total (s)   self (s)
 2664              0.003914     for part in keys(b:color_pattern)
                            
                                  "if b:color_pattern[part]=="ffffff"
                                    "echoe part
                                  "endif
                                  
 2646   0.107604   0.014870       call s:MatchColorValue(b:color_pattern[part], part)
                                  "echoe color
                                  "echoe b:color_pattern[color]
                                  "let group = 'cssColor' . tolower(strpart(b:color_pattern[part]["color"], 1))
                                  ""exe 'syn match' group '/'.escape(pattern, '/').'/ contained'
                                  "exe 'syn cluster cssColors add='.group
                                  "exe 'hi' group s:color_prefix.'bg='.b:color_pattern[part]["bg"] s:color_prefix.'fg='.b:color_pattern[part]["fg"]
                                  
                                  "if !exists('b:matchescache')
                                    "let b:matchescache={}
                                  "endif
                            
                                  "let b:matchescache[part] = matchadd(group, part, -1)
 2646              0.004587     endfor

FUNCTION  <SNR>82_FindItemAtCursor()
Called 24 times
Total time:   0.002584
 Self time:   0.001353

count  total (s)   self (s)
   24              0.000599     let l:info = get(g:ale_buffer_info, bufnr('%'), {'loclist': []})
   24              0.000146     let l:pos = getcurpos()
   24   0.001616   0.000385     let l:index = ale#util#BinarySearch(l:info.loclist, l:pos[1], l:pos[2])
   24              0.000101     let l:loc = l:index >= 0 ? l:info.loclist[l:index] : {}
                            
   24              0.000056     return [l:info, l:loc]

FUNCTION  <SNR>65_Highlight_Matching_Pair()
Called 24 times
Total time:   0.002693
 Self time:   0.002693

count  total (s)   self (s)
                              " Remove any previous match.
   24              0.000105   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   24              0.000129   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   24              0.000085   let c_lnum = line('.')
   24              0.000060   let c_col = col('.')
   24              0.000032   let before = 0
                            
   24              0.000124   let text = getline(c_lnum)
   24              0.000440   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   24              0.000062   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
   24              0.000134     let [c_before, c] = matches[1:2]
   24              0.000023   endif
   24              0.000582   let plist = split(&matchpairs, '.\zs[:,]')
   24              0.000108   let i = index(plist, c)
   24              0.000035   if i < 0
                                " not found, in Insert mode try character before the cursor
   24              0.000082     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
   24              0.000026     if i < 0
                                  " not found, nothing to do
   24              0.000026       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>80_SetCompleteFunc()
Called 16 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
   16              0.000077   let &completefunc = 'youcompleteme#Complete'
   16              0.000052   let &l:completefunc = 'youcompleteme#Complete'

FUNCTION  <SNR>205_StopPreviousJobs()
Called 5 times
Total time:   0.000515
 Self time:   0.000255

count  total (s)   self (s)
    5              0.000024     if !has_key(g:ale_buffer_info, a:buffer)
                                    " Do nothing if we didn't run anything for the buffer.
                                    return
                                endif
                            
    5              0.000012     let l:new_job_list = []
                            
    6              0.000021     for l:job in g:ale_buffer_info[a:buffer].job_list
    1   0.000036   0.000004         let l:job_id = s:GetJobID(l:job)
                            
    1              0.000007         if has_key(s:job_info_map, l:job_id)&& s:job_info_map[l:job_id].linter.name ==# a:linter.name
                                        " Stop jobs which match the buffer and linter.
    1   0.000236   0.000008             call ale#engine#ClearJob(l:job)
    1              0.000001         else
                                        " Keep other jobs in the list.
                                        call add(l:new_job_list, l:job)
                                    endif
    1              0.000002     endfor
                            
                                " Update the list, removing the previously run job.
    5              0.000033     let g:ale_buffer_info[a:buffer].job_list = l:new_job_list

FUNCTION  <SNR>205_SetExitCode()
Called 1 time
Total time:   0.000102
 Self time:   0.000041

count  total (s)   self (s)
    1   0.000051   0.000019     let l:job_id = s:GetJobID(a:job)
                            
    1              0.000003     if !has_key(s:job_info_map, l:job_id)
                                    return
                                endif
                            
    1              0.000002     let l:buffer = s:job_info_map[l:job_id].buffer
                            
    1   0.000041   0.000012     call ale#history#SetExitCode(l:buffer, l:job_id, a:exit_code)

FUNCTION  <SNR>82_StopCursorTimer()
Called 24 times
Total time:   0.000259
 Self time:   0.000259

count  total (s)   self (s)
   24              0.000058     if s:cursor_timer != -1
   24              0.000086         call timer_stop(s:cursor_timer)
   24              0.000065         let s:cursor_timer = -1
   24              0.000020     endif

FUNCTION  <SNR>208_GroupLoclistItems()
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000002     let l:grouped_items = []
    1              0.000001     let l:last_lnum = -1
                            
    4              0.000004     for l:obj in a:loclist
                                    " Create a new sub-List when we hit a new line.
    3              0.000005         if l:obj.lnum != l:last_lnum
    2              0.000004             call add(l:grouped_items, [])
    2              0.000001         endif
                            
    3              0.000007         call add(l:grouped_items[-1], l:obj)
    3              0.000004         let l:last_lnum = l:obj.lnum
    3              0.000001     endfor
                            
    1              0.000001     return l:grouped_items

FUNCTION  <SNR>80_OnCursorMovedNormalMode()
Called 24 times
Total time:   0.006112
 Self time:   0.001495

count  total (s)   self (s)
   24   0.001346   0.000130   if !s:AllowedToCompleteInCurrentBuffer()
    6              0.000006     return
                              endif
                            
   18   0.003497   0.000096   call s:OnFileReadyToParse()
   18              0.001186   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  ale#util#GetLineCount()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000008     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  <SNR>21_record()
Called 52 times
Total time:   0.019573
 Self time:   0.003104

count  total (s)   self (s)
   52              0.000342 	if s:locked | retu | en
   52              0.000282 	let bufnr = a:bufnr + 0
   52              0.000368 	let bufname = bufname(bufnr)
   52              0.000231 	if bufnr > 0 && !empty(bufname)
   52              0.000826 		cal filter(s:mrbs, 'v:val != bufnr')
   52              0.000209 		cal insert(s:mrbs, bufnr)
   52   0.017110   0.000641 		cal s:addtomrufs(bufname)
   52              0.000043 	en

FUNCTION  ale#util#BinarySearch()
Called 24 times
Total time:   0.001231
 Self time:   0.001231

count  total (s)   self (s)
   24              0.000059     let l:min = 0
   24              0.000099     let l:max = len(a:loclist) - 1
   24              0.000069     let l:last_column_match = -1
                            
   42              0.000079     while 1
   42              0.000091         if l:max < l:min
   24              0.000050             return l:last_column_match
                                    endif
                            
   18              0.000054         let l:mid = (l:min + l:max) / 2
   18              0.000059         let l:obj = a:loclist[l:mid]
                            
                                    " Binary search to get on the same line
   18              0.000058         if a:loclist[l:mid]['lnum'] < a:line
    2              0.000006             let l:min = l:mid + 1
    2              0.000004         elseif a:loclist[l:mid]['lnum'] > a:line
    8              0.000015             let l:max = l:mid - 1
    8              0.000006         else
    8              0.000012             let l:last_column_match = l:mid
                            
                                        " Binary search to get the same column, or near it
    8              0.000014             if a:loclist[l:mid]['col'] < a:column
                                            let l:min = l:mid + 1
                                        elseif a:loclist[l:mid]['col'] > a:column
    8              0.000011                 let l:max = l:mid - 1
    8              0.000005             else
                                            return l:mid
                                        endif
    8              0.000006         endif
   18              0.000038     endwhile

FUNCTION  <SNR>82_GetMessage()
Called 6 times
Total time:   0.000458
 Self time:   0.000458

count  total (s)   self (s)
    6              0.000013     let l:msg = g:ale_echo_msg_format
    6              0.000022     let l:type = a:type ==# 'E'   ? g:ale_echo_msg_error_str   : g:ale_echo_msg_warning_str
                                " Capitalize the 1st character
    6              0.000040     let l:text = toupper(a:text[0]) . a:text[1:-1]
                            
                                " Replace handlers if they exist
   18              0.000116     for [l:k, l:v] in items({'linter': a:linter, 'severity': l:type})
   12              0.000173         let l:msg = substitute(l:msg, '\V%' . l:k . '%', l:v, '')
   12              0.000018     endfor
                            
    6              0.000025     return printf(l:msg, l:text)

FUNCTION  <SNR>80_AllowedToCompleteInBuffer()
Called 50 times
Total time:   0.002128
 Self time:   0.001834

count  total (s)   self (s)
   50              0.000323   let buffer_filetype = getbufvar( a:buffer, '&filetype' )
                            
   50              0.000382   if empty( buffer_filetype ) || getbufvar( a:buffer, '&buftype' ) ==# 'nofile' || buffer_filetype ==# 'qf'
   11              0.000010     return 0
                              endif
                            
   39   0.000529   0.000235   if s:DisableOnLargeFile( a:buffer )
                                return 0
                              endif
                            
   39              0.000249   let whitelist_allows = has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, buffer_filetype )
   39              0.000180   let blacklist_allows = !has_key( g:ycm_filetype_blacklist, buffer_filetype )
                            
   39              0.000080   return whitelist_allows && blacklist_allows

FUNCTION  ale#sign#ParseSigns()
Called 1 time
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
                                " Matches output like :
                                " line=4  id=1  name=ALEErrorSign
                                " строка=1  id=1000001  имя=ALEErrorSign
                                " 行=1  識別子=1000001  名前=ALEWarningSign
                                " línea=12 id=1000001 nombre=ALEWarningSign
                                " riga=1 id=1000001, nome=ALEWarningSign
    1              0.000002     let l:pattern = '^.*=\(\d\+\).*=\(\d\+\).*=ALE\(Error\|Warning\|Dummy\)Sign'
    1              0.000001     let l:result = []
                            
    5              0.000006     for l:line in a:line_list
    4              0.000078         let l:match = matchlist(l:line, l:pattern)
                            
    4              0.000007         if len(l:match) > 0
    2              0.000017             call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   'ALE' . l:match[3] . 'Sign',])
    2              0.000002         endif
    4              0.000002     endfor
                            
    1              0.000001     return l:result

FUNCTION  ale#cursor#TruncatedEcho()
Called 6 times
Total time:   0.001153
 Self time:   0.000147

count  total (s)   self (s)
    6              0.000014     let l:message = a:message
                                " Change tabs to spaces.
    6              0.000033     let l:message = substitute(l:message, "\t", ' ', 'g')
                                " Remove any newlines in the message.
    6              0.000024     let l:message = substitute(l:message, "\n", '', 'g')
                            
    6   0.001067   0.000061     call s:EchoWithShortMess('on', l:message)

FUNCTION  <SNR>80_OnFileReadyToParse()
Called 34 times
Total time:   0.026129
 Self time:   0.014413

count  total (s)   self (s)
   34   0.012060   0.000344   if s:Pyeval( 'ycm_state.ServerBecomesReady()' )
                                " Server was not ready until now and could not parse previous requests for
                                " the current buffer. We need to send them again.
                                exec s:python_command "ycm_state.OnBufferVisit()"
                                exec s:python_command "ycm_state.OnFileReadyToParse()"
                                " Setting the omnifunc requires us to ask the server if it has a native
                                " semantic completer for the current buffer's filetype. Since we only set it
                                " when entering a buffer or changing the filetype, we try to set it again
                                " now that the server is ready.
                                call s:SetOmnicompleteFunc()
                                return
                              endif
                            
                              " Order is important here; we need to extract any information before
                              " reparsing the file again. If we sent the new parse request first, then
                              " the response would always be pending when we called
                              " HandleFileParseRequest.
   34              0.012566   exec s:python_command "ycm_state.HandleFileParseRequest()"
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one.
   34              0.000457   if b:changedtick != get( b:, 'ycm_changedtick', -1 )
                                exec s:python_command "ycm_state.OnFileReadyToParse()"
                                let b:ycm_changedtick = b:changedtick
                              endif

FUNCTION  ale#highlight#RemoveHighlights()
Called 1 time
Total time:   0.001269
 Self time:   0.000034

count  total (s)   self (s)
    1   0.000040   0.000013     let l:current_id_map = s:GetCurrentMatchIDs(a:loclist)
                            
    1   0.001222   0.000014     for l:match in s:GetALEMatches()
                                    if !has_key(l:current_id_map, l:match.id)
                                        call matchdelete(l:match.id)
                                    endif
                                endfor

FUNCTION  <SNR>205_IsJobRunning()
Called 1 time
Total time:   0.000146
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000003     if has('nvim')
                                    try
                                        " In NeoVim, if the job isn't running, jobpid() will throw.
                                        call jobpid(a:job)
                                        return 1
                                    catch
                                    endtry
                            
                                    return 0
                                endif
                            
    1   0.000133   0.000019     return job_status(a:job) ==# 'run'

FUNCTION  <SNR>208_GetItemsWithSignIDs()
Called 1 time
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000002     let l:items_by_sign_id = {}
                            
    4              0.000004     for l:item in a:loclist
    3              0.000006         if has_key(l:item, 'sign_id')
                                        if !has_key(l:items_by_sign_id, l:item.sign_id)
                                            let l:items_by_sign_id[l:item.sign_id] = []
                                        endif
                            
                                        call add(l:items_by_sign_id[l:item.sign_id], l:item)
                                    endif
    3              0.000001     endfor
                            
    1              0.000001     return l:items_by_sign_id

FUNCTION  ale#Lint()
Called 3 times
Total time:   0.006639
 Self time:   0.000386

count  total (s)   self (s)
    3   0.000489   0.000045     if ale#ShouldDoNothing()
                                    return
                                endif
                            
    3              0.000023     let l:buffer = bufnr('%')
    3   0.001011   0.000031     let l:linters = ale#linter#Get(&filetype)
    3              0.000007     let l:should_lint_file = 0
                            
                                " Check if we previously requested checking the file.
    3              0.000018     if has_key(s:should_lint_file_for_buffer, l:buffer)
    3              0.000015         unlet s:should_lint_file_for_buffer[l:buffer]
    3              0.000008         let l:should_lint_file = 1
    3              0.000004     endif
                            
                                " Initialise the buffer information if needed.
    3   0.000088   0.000032     call ale#engine#InitBufferInfo(l:buffer)
                            
                                " Clear the new loclist again, so we will work with all new items.
    3              0.000014     let g:ale_buffer_info[l:buffer].new_loclist = []
                            
    3              0.000005     if l:should_lint_file
                                    " Clear loclist items for files if we are checking files again.
    3              0.000011         let g:ale_buffer_info[l:buffer].lint_file_loclist = []
    3              0.000004     else
                                    " Otherwise, don't run any `lint_file` linters
                                    " We will continue running any linters which are currently checking
                                    " the file, and the items will be mixed together with any new items.
                                    call filter(l:linters, '!v:val.lint_file')
                                endif
                            
    7              0.000022     for l:linter in l:linters
    4   0.004831   0.000058         call ale#engine#Invoke(l:buffer, l:linter)
    4              0.000014     endfor

FUNCTION  ale#linter#GetAll()
Called 41 times
Total time:   0.002261
 Self time:   0.002261

count  total (s)   self (s)
   41              0.000087     let l:combined_linters = []
                            
   82              0.000158     for l:filetype in a:filetypes
                                    " Load linter defintions from files if we haven't loaded them yet.
   41              0.000155         if !has_key(s:linters, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        " Always set an empty List for the loaded linters if we don't find
                                        " any. This will prevent us from executing the runtime command
                                        " many times, redundantly.
                                        if !has_key(s:linters, l:filetype)
                                            let s:linters[l:filetype] = []
                                        endif
                                    endif
                            
   41              0.000280         call extend(l:combined_linters, get(s:linters, l:filetype, []))
   41              0.000056     endfor
                            
   41              0.000091     return l:combined_linters

FUNCTION  ale#linter#ResolveFiletype()
Called 41 times
Total time:   0.000872
 Self time:   0.000872

count  total (s)   self (s)
                                " Try and get an aliased file type either from the user's Dictionary, or
                                " our default Dictionary, otherwise use the filetype as-is.
   41              0.000458     let l:filetype = get(   g:ale_linter_aliases,   a:original_filetype,   get(       s:default_ale_linter_aliases,       a:original_filetype,       a:original_filetype   ))
                            
   41              0.000189     if type(l:filetype) != type([])
   41              0.000085         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  ale#engine#RemoveManagedFiles()
Called 1 time
Total time:   0.000309
 Self time:   0.000272

count  total (s)   self (s)
    1              0.000003     if !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
                                " We can't delete anything in a sandbox, so wait until we escape from
                                " it to delete temporary files and directories.
    1   0.000040   0.000003     if ale#util#InSandbox()
                                    return
                                endif
                            
                                " Delete files with a call akin to a plan `rm` command.
    1              0.000003     for l:filename in g:ale_buffer_info[a:buffer].temporary_file_list
                                    call delete(l:filename)
                                endfor
                            
    1              0.000005     let g:ale_buffer_info[a:buffer].temporary_file_list = []
                            
                                " Delete directories like `rm -rf`.
                                " Directories are handled differently from files, so paths that are
                                " intended to be single files can be set up for automatic deletion without
                                " accidentally deleting entire directories.
    2              0.000004     for l:directory in g:ale_buffer_info[a:buffer].temporary_directory_list
    1              0.000233         call delete(l:directory, 'rf')
    1              0.000002     endfor
                            
    1              0.000005     let g:ale_buffer_info[a:buffer].temporary_directory_list = []

FUNCTION  <SNR>205_TemporaryFilename()
Called 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000008     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
    1              0.000004     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
                                endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
    1              0.000014     return tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  <SNR>179_VimCssInit()
Called 18 times
Total time:   0.135883
 Self time:   0.003740

count  total (s)   self (s)
                            
   18              0.000023     if a:update==1
   18   0.001912   0.000093         call s:ClearMatches()
   18              0.000014     endif
   18              0.000851     :set isk+=-
   18              0.000724     :set isk+=#
   18              0.000694     :set isk+=.
                            
   18              0.001153     if len(keys(b:color_pattern))>0
   18   0.130444   0.000120         call s:RestoreColors()
   18              0.000016         return
                                endif
                            
                                "let b:matchescache = {}
                            
                                call s:AdditionalColors()
                            
                                "for i in range(1, line("$"))
                                    call s:PreviewCSSColor(join(getline(1,'$'), "\n"))
                                "endfor
                            

FUNCTION  ale#list#SetLists()
Called 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000001     if g:ale_set_quickfix
                                    call setqflist(a:loclist)
                                elseif g:ale_set_loclist
                                    " If windows support is off, bufwinid() may not exist.
    1              0.000002         if exists('*bufwinid')
                                        " Set the results on the window for the buffer.
    1              0.000014             call setloclist(bufwinid(str2nr(a:buffer)), a:loclist)
    1              0.000001         else
                                        " Set the results in the current window.
                                        " This may not be the same window we ran the linters for, but
                                        " it's better than nothing.
                                        call setloclist(0, a:loclist)
                                    endif
    1              0.000001     endif
                            
                                " If we don't auto-open lists, bail out here.
    1              0.000001     if !g:ale_open_list && !g:ale_keep_list_window_open
    1              0.000001         return
                                endif
                            
                                " If we have errors in our list, open the list. Only if it isn't already open
                                if len(a:loclist) > 0 || g:ale_keep_list_window_open
                                    let l:winnr = winnr()
                            
                                    if !ale#list#IsQuickfixOpen()
                                      if g:ale_set_quickfix
                                          copen
                                      elseif g:ale_set_loclist
                                          lopen
                                      endif
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr !=# winnr()
                                        wincmd p
                                    endif
                            
                                    " Only close if the list is totally empty (relying on Vim's state, not our
                                    " own). This keeps us from closing the window when other plugins have
                                    " populated it.
                                elseif !g:ale_keep_list_window_open && g:ale_set_quickfix && len(getqflist()) == 0
                                    cclose
                                elseif !g:ale_keep_list_window_open && len(getloclist(0)) == 0
                                    lclose
                                endif

FUNCTION  ale#util#InSandbox()
Called 55 times
Total time:   0.003412
 Self time:   0.003412

count  total (s)   self (s)
   55              0.000102     try
   55              0.000513         call setbufvar('%', '', '')
                                catch /^Vim\%((\a\+)\)\=:E48/
                                    " E48 is the sandbox error.
                                    return 1
                                catch
                                    " If we're not in a sandbox, we'll get another error about an
                                    " invalid buffer variable name.
   55              0.000181     endtry
                            
   55              0.000078     return 0

FUNCTION  ale#engine#Invoke()
Called 4 times
Total time:   0.004773
 Self time:   0.000505

count  total (s)   self (s)
                                " Stop previous jobs for the same linter.
    4   0.000238   0.000044     call s:StopPreviousJobs(a:buffer, a:linter)
                            
    4   0.000773   0.000077     let l:executable = has_key(a:linter, 'executable_callback')   ? ale#util#GetFunction(a:linter.executable_callback)(a:buffer)   : a:linter.executable
                            
                                " Run this program if it can be executed.
    4              0.000291     if executable(l:executable)
    1   0.003428   0.000050         call s:InvokeChain(a:buffer, a:linter, 0, [])
    1              0.000001     endif

FUNCTION  <SNR>80_SetUpCompleteopt()
Called 16 times
Total time:   0.000428
 Self time:   0.000428

count  total (s)   self (s)
                              " Some plugins (I'm looking at you, vim-notes) change completeopt by for
                              " instance adding 'longest'. This breaks YCM. So we force our settings.
                              " There's no two ways about this: if you want to use YCM then you have to
                              " have these completeopt settings, otherwise YCM won't work at all.
                            
                              " We need menuone in completeopt, otherwise when there's only one candidate
                              " for completion, the menu doesn't show up.
   16              0.000160   set completeopt-=menu
   16              0.000054   set completeopt+=menuone
                            
                              " This is unnecessary with our features. People use this option to insert
                              " the common prefix of all the matches and then add more differentiating chars
                              " so that they can select a more specific match. With our features, they
                              " don't need to insert the prefix; they just type the differentiating chars.
                              " Also, having this option set breaks the plugin.
   16              0.000043   set completeopt-=longest
                            
   16              0.000030   if g:ycm_add_preview_to_completeopt
                                set completeopt+=preview
                              endif

FUNCTION  ale#engine#FixLocList()
Called 1 time
Total time:   0.000165
 Self time:   0.000157

count  total (s)   self (s)
    1              0.000002     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
    1   0.000019   0.000011     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
    4              0.000005     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
    3              0.000045         let l:item = {   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'bufnr': get(l:old_item, 'bufnr', a:buffer),   'vcol': get(l:old_item, 'vcol', 0),   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter.name,}
                            
    3              0.000007         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
    3              0.000004         if l:item.lnum == 0
                                        " When errors appear at line 0, put them at line 1 instead.
                                        let l:item.lnum = 1
                                    elseif l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        let l:item.lnum = l:last_line_number
                                    endif
                            
    3              0.000007         call add(l:new_loclist, l:item)
    3              0.000003     endfor
                            
    1              0.000001     return l:new_loclist

FUNCTION  <SNR>208_SetDummySignIfNeeded()
Called 1 time
Total time:   0.000997
 Self time:   0.000986

count  total (s)   self (s)
    1   0.000025   0.000014     let l:is_dummy_sign_set = s:IsDummySignSet(a:current_sign_list)
                            
                                " If we haven't already set a dummy sign, and we have some previous signs
                                " or always want a dummy sign, then set one, to keep the sign column open.
    1              0.000003     if !l:is_dummy_sign_set && (a:new_signs || g:ale_sign_column_always)
    1              0.000961         execute 'sign place ' .  g:ale_sign_offset   . ' line=1 name=ALEDummySign buffer='   . a:buffer
                            
    1              0.000003         let l:is_dummy_sign_set = 1
    1              0.000000     endif
                            
    1              0.000001     return l:is_dummy_sign_set

FUNCTION  ale#engine#FormatCommand()
Called 1 time
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
    1              0.000003     let l:temporary_file = ''
    1              0.000002     let l:command = a:command
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
    1              0.000012     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace all %s occurences in the string with the name of the current
                                " file.
    1              0.000006     if l:command =~# '%s'
    1              0.000032         let l:filename = fnamemodify(bufname(a:buffer), ':p')
    1              0.000027         let l:command = substitute(l:command, '%s', '\=fnameescape(l:filename)', 'g')
    1              0.000001     endif
                            
    1              0.000005     if l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = substitute(l:command, '%t', '\=fnameescape(l:temporary_file)', 'g')
                                endif
                            
                                " Finish formatting so %% becomes %.
    1              0.000011     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
    1              0.000004     return [l:temporary_file, l:command]

FUNCTION  ale#highlight#SetHighlights()
Called 1 time
Total time:   0.001405
 Self time:   0.000024

count  total (s)   self (s)
                                " Only set set items for the buffer if ALE is enabled.
    1              0.000001     if g:ale_enabled
                                    " Set a list of items to be set as highlights for a buffer when
                                    " we next open it.
                                    "
                                    " We'll filter the loclist down to items we can set now.
    1              0.000013         let s:buffer_highlights[a:buffer] = filter(   copy(a:loclist),   'v:val.bufnr == a:buffer && v:val.col > 0')
                            
                                    " Update highlights for the current buffer, which may or may not
                                    " be the buffer we just set highlights for.
    1   0.001385   0.000004         call ale#highlight#UpdateHighlights()
    1              0.000001     endif

FUNCTION  <SNR>208_UpdateLineNumbers()
Called 1 time
Total time:   0.000061
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000056   0.000012     let l:items_by_sign_id = s:GetItemsWithSignIDs(a:loclist)
                            
                                " Do nothing if there's nothing to work with.
    1              0.000002     if empty(l:items_by_sign_id)
    1              0.000000         return
                                endif
                            
                                for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    for l:obj in get(l:items_by_sign_id, l:sign_id, [])
                                        let l:obj.lnum = l:line
                                    endfor
                                endfor
                            
                                " Sort items again.
                                call sort(a:loclist, 'ale#util#LocItemCompare')

FUNCTION  FileBeagleStatusLineFilterInfo()
Called 13 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
   13              0.000101     return exists("b:filebeagle_directory_viewer") && b:filebeagle_directory_viewer.is_filtered && !empty(b:filebeagle_directory_viewer.filter_exp) ? b:filebeagle_directory_viewer.filter_exp : ''

FUNCTION  ale#engine#SetResults()
Called 1 time
Total time:   0.007078
 Self time:   0.000069

count  total (s)   self (s)
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    1              0.000001     if g:ale_set_signs
    1   0.005580   0.000015         call ale#sign#SetSigns(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000002     if g:ale_set_quickfix || g:ale_set_loclist
    1   0.000047   0.000014         call ale#list#SetLists(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000003     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
                                    call ale#statusline#Update(a:buffer, a:loclist)
                                endif
                            
    1              0.000001     if g:ale_set_highlights
    1   0.001417   0.000012         call ale#highlight#SetHighlights(a:buffer, a:loclist)
    1              0.000001     endif
                            
    1              0.000002     if g:ale_echo_cursor
                                    " Try and echo the warning now.
                                    " This will only do something meaningful if we're in normal mode.
    1   0.000014   0.000008         call ale#cursor#EchoCursorWarning()
    1              0.000001     endif

FUNCTION  <SNR>205_HandleExitStatusVim()
Called 1 time
Total time:   0.000114
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000114   0.000012     call s:SetExitCode(a:job, a:exit_code)

FUNCTION  ale#engine#ClearJob()
Called 1 time
Total time:   0.000228
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000003     if get(g:, 'ale_run_synchronously') == 1
                                    call remove(s:job_info_map, a:job)
                            
                                    return
                                endif
                            
    1   0.000029   0.000003     let l:job_id = s:GetJobID(a:job)
                            
    1              0.000002     if has('nvim')
                                    call jobstop(a:job)
                                else
                                    " We must close the channel for reading the buffer if it is open
                                    " when stopping a job. Otherwise, we will get errors in the status line.
    1              0.000004         if ch_status(job_getchannel(a:job)) ==# 'open'
                                        call ch_close_in(job_getchannel(a:job))
                                    endif
                            
                                    " Ask nicely for the job to stop.
    1              0.000006         call job_stop(a:job)
    1              0.000001     endif
                            
                                " If a job doesn't stop immediately, queue a timer which will
                                " send SIGKILL to the job, if it's alive by the time the timer ticks.
    1   0.000158   0.000012     if s:IsJobRunning(a:job)
                                    let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = a:job
                                endif
                            
    1              0.000002     if has_key(s:job_info_map, l:job_id)
    1              0.000004         call remove(s:job_info_map, l:job_id)
    1              0.000000     endif

FUNCTION  <SNR>21_addtomrufs()
Called 52 times
Total time:   0.016469
 Self time:   0.016469

count  total (s)   self (s)
   52              0.002750 	let fn = fnamemodify(a:fname, ':p')
   52              0.000635 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
   52              0.011189 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
                            	en
   44              0.000470 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
   44              0.000064 	if idx
   22              0.000465 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
   22              0.000082 		cal insert(s:mrufs, fn)
   22              0.000085 		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
   22              0.000025 	en

FUNCTION  ale#history#Add()
Called 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000002     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    let g:ale_buffer_info[a:buffer].history = []
                            
                                    return
                                endif
                            
    1              0.000004     let l:history = g:ale_buffer_info[a:buffer].history
                            
                                " Remove the first item if we hit the max history size.
    1              0.000003     if len(l:history) >= g:ale_max_buffer_history_size
                                    let l:history = l:history[1:]
                                endif
                            
    1              0.000012     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
    1              0.000004     let g:ale_buffer_info[a:buffer].history = l:history

FUNCTION  ale#util#GetMatches()
Called 1 time
Total time:   0.000205
 Self time:   0.000205

count  total (s)   self (s)
    1              0.000002     let l:matches = []
    1              0.000004     let l:lines = type(a:lines) == type([]) ? a:lines : [a:lines]
    1              0.000004     let l:patterns = type(a:patterns) == type([]) ? a:patterns : [a:patterns]
                            
    4              0.000006     for l:line in l:lines
    3              0.000004         for l:pattern in l:patterns
    3              0.000087             let l:match = matchlist(l:line, l:pattern)
                            
    3              0.000062             if !empty(l:match)
    3              0.000006                 call add(l:matches, l:match)
    3              0.000002                 break
                                        endif
                                    endfor
    3              0.000002     endfor
                            
    1              0.000001     return l:matches

FUNCTION  <SNR>179_ClearMatches()
Called 18 times
Total time:   0.001819
 Self time:   0.001819

count  total (s)   self (s)
   18              0.001280   call clearmatches()
                              
   18              0.000049   if !exists('b:matchescache')
                                return
                              endif
                              "for i in values(b:matchescache)
                                "call matchdelete(i)
                              "endfor
   18              0.000413   unlet b:matchescache

FUNCTION  ale#path#ResolveLocalPath()
Called 2 times
Total time:   0.001067
 Self time:   0.000062

count  total (s)   self (s)
                                " Search for a locally installed file first.
    2   0.001037   0.000032     let l:path = ale#path#FindNearestFile(a:buffer, a:search_string)
                            
                                " If the serach fails, try the global executable instead.
    2              0.000007     if empty(l:path)
    2              0.000007         let l:path = a:global_fallback
    2              0.000002     endif
                            
    2              0.000004     return l:path

FUNCTION  <SNR>205_CreateTemporaryFileForJob()
Called 1 time
Total time:   0.000449
 Self time:   0.000438

count  total (s)   self (s)
    1              0.000004     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
                                endif
                            
    1              0.000007     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
    1              0.000104     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
    1   0.000040   0.000029     call ale#engine#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
    1              0.000277     call writefile(getbufline(a:buffer, 1, '$'), a:temporary_file)
                            
    1              0.000004     return 1

FUNCTION  ale#sign#ReadSigns()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000003     redir => l:output
    1              0.000010        silent exec 'sign place buffer=' . a:buffer
    1              0.000003     redir end
                            
    1              0.000007     return split(l:output, "\n")

FUNCTION  <SNR>80_OnBufferEnter()
Called 26 times
Total time:   0.046856
 Self time:   0.016829

count  total (s)   self (s)
   26   0.001845   0.000130   if !s:VisitedBufferRequiresReparse()
   10              0.000005     return
                              endif
                            
   16   0.000509   0.000081   call s:SetUpCompleteopt()
   16   0.000208   0.000061   call s:SetCompleteFunc()
   16   0.005091   0.000082   call s:SetOmnicompleteFunc()
                            
   16              0.016066   exec s:python_command "ycm_state.OnBufferVisit()"
   16   0.023045   0.000317   call s:OnFileReadyToParse()

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 24 times
Total time:   0.003530
 Self time:   0.001053

count  total (s)   self (s)
   24   0.002387   0.000169     if ale#ShouldDoNothing()
                                    return
                                endif
                            
   24   0.000417   0.000158     call s:StopCursorTimer()
                            
   24              0.000211     let l:pos = getcurpos()[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
   24              0.000063     if l:pos != s:last_pos
   24              0.000069         let s:last_pos = l:pos
   24              0.000160         let s:cursor_timer = timer_start(10, function('ale#cursor#EchoCursorWarning'))
   24              0.000021     endif

FUNCTION  ale#util#LocItemCompare()
Called 3 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    3              0.000005     if a:left['lnum'] < a:right['lnum']
    2              0.000001         return -1
                                endif
                            
    1              0.000002     if a:left['lnum'] > a:right['lnum']
                                    return 1
                                endif
                            
    1              0.000001     if a:left['col'] < a:right['col']
    1              0.000001         return -1
                                endif
                            
                                if a:left['col'] > a:right['col']
                                    return 1
                                endif
                            
                                return 0

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   18   0.135883   0.003740  <SNR>179_VimCssInit()
   18   0.130324   0.037590  <SNR>179_RestoreColors()
 2646   0.092734             <SNR>179_MatchColorValue()
   26   0.075853   0.000879  <SNR>19_OpenDirHere()
    4   0.074974   0.000079  filebeagle#FileBeagleOpen()
    4   0.074895   0.074751  6()
   26   0.046856   0.016829  <SNR>80_OnBufferEnter()
   34   0.026129   0.014413  <SNR>80_OnFileReadyToParse()
   52   0.019573   0.003104  <SNR>21_record()
   52   0.016469             <SNR>21_addtomrufs()
   50   0.016324             <SNR>80_Pyeval()
   26   0.011021   0.002000  ale#Queue()
    1   0.008986   0.000220  <SNR>205_HandleExitVim()
    1   0.008766   0.000302  <SNR>205_HandleExit()
   29   0.008127   0.004994  ale#linter#Get()
    1   0.007078   0.000069  ale#engine#SetResults()
    3   0.006639   0.000386  ale#Lint()
   24   0.006112   0.001495  <SNR>80_OnCursorMovedNormalMode()
   25   0.005801   0.001606  ale#cursor#EchoCursorWarning()
    1   0.005565   0.002513  ale#sign#SetSigns()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 2646              0.092734  <SNR>179_MatchColorValue()
    4   0.074895   0.074751  6()
   18   0.130324   0.037590  <SNR>179_RestoreColors()
   26   0.046856   0.016829  <SNR>80_OnBufferEnter()
   52              0.016469  <SNR>21_addtomrufs()
   50              0.016324  <SNR>80_Pyeval()
   34   0.026129   0.014413  <SNR>80_OnFileReadyToParse()
   29   0.008127   0.004994  ale#linter#Get()
   18   0.135883   0.003740  <SNR>179_VimCssInit()
   55              0.003412  ale#util#InSandbox()
   52   0.019573   0.003104  <SNR>21_record()
   53   0.003374   0.002698  <SNR>74_Setup()
   24              0.002693  <SNR>65_Highlight_Matching_Pair()
    1   0.005565   0.002513  ale#sign#SetSigns()
   41              0.002261  ale#linter#GetAll()
   26   0.011021   0.002000  ale#Queue()
   50   0.002128   0.001834  <SNR>80_AllowedToCompleteInBuffer()
   18              0.001819  <SNR>179_ClearMatches()
    1   0.002520   0.001775  <SNR>205_RunJob()
    1              0.001753  <SNR>208_PlaceNewSigns()

